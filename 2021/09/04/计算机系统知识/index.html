<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="Kai">





<title>计算机基础知识笔记 | 面向兴趣编程</title>



    <link rel="icon" href="/icoimage.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 6.3.0"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">anonymity&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">anonymity&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6;    // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function () {
            tocbot.refresh(obj_merge(tocbot_default_config, { hasInnerContainers: true }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function () {
        tocbot.init(obj_merge(tocbot_default_config, { collapseDepth: 1 }));
    });

    function expandToc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, { collapseDepth: expanded ? 1 : DEPTH_MAX }));
        b.innerText = expanded ? 'Expand all' : 'Collapse all';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">计算机基础知识笔记</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">Kai</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">September 4, 2021&nbsp;&nbsp;21:10:00</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <h1 id="计算机系统知识"><a href="#计算机系统知识" class="headerlink" title="计算机系统知识"></a>计算机系统知识</h1><p><strong>计算机的基本硬件系统由：运算器，控制器，存储器，输入设备和输出设备组成。</strong></p>
<p><strong>运算器，控制器</strong>等部件被集成在一起称为 中央处理单元 （CPU）。</p>
<p>CPU 是硬件系统的核心，用于数据的加工处理，能完成各种算术，逻辑运算及控制功能。</p>
<p>存储器是计算机系统中的记忆设备，分为内部存储器和外部存储器。前者速度快，容量小，一般用于临时存放程序，数据及中间结果。后者则容量大，速度慢，可以长期保存程序和数据。</p>
<p>输入设备和输出设备统称为外设，输入设备用于输入原始数据及各种命令，输出设备则用于输出计算机运行结果。</p>
<h2 id="中央处理单元（CPU）"><a href="#中央处理单元（CPU）" class="headerlink" title="中央处理单元（CPU）"></a>中央处理单元（CPU）</h2><p>中央处理单元是计算机系统的核心部件，它负责获取程序指令，对指令进行译码并加以执行。</p>
<p>1.程序控制：CPU 通过执行指令来控制程序的执行顺序，这是CPU 的重要功能。</p>
<p>2.操作控制：一条指令功能的实现需要若干操作信号来配合，CPU产生的每条指令的操作信号并将操作信号送往对应的部件，控制相应的部件按指令的功能要求进行操作。</p>
<p>3.时间控制：CPU对各种操作进行时间上的控制，即指令执行过程中操作信号的出现时间，持续时间及出现的时间顺序都需要进行严格控制。</p>
<p>4.数据处理： CPU 通过对数据进行算术运算及逻辑运算等方式进行加工处理，数据加工处理结果被人所利用。对数据加工处理是CPU 最根本的任务。</p>
<p>此外，CPU 需要对系统内部和外部的中断（异常）做出响应，进行相应的处理。</p>
<h2 id="CPU-的组成"><a href="#CPU-的组成" class="headerlink" title="CPU 的组成"></a>CPU 的组成</h2><p>CPU 主要由运算器，控制器，寄存器组 ，内部总线等部件组成。</p>
<h3 id="运算器"><a href="#运算器" class="headerlink" title="运算器"></a><strong>运算器</strong></h3><p>运算器是由算术逻辑单元，累加寄存器，数据缓冲寄存器和状态条件寄存器等组成，它是数据加工处理部件，用于完成计算机的各种计算和逻辑运算。运算器主要有两个功能：</p>
<p>1.执行所有的算术运算，列如加减乘除等基本运算</p>
<p>2.执行所有的逻辑运算并进行逻辑测试，例如或，与，非，零值测试或两个值的比较等。</p>
<p><strong>算术逻辑单元（ALU）</strong></p>
<p>ALU是运算器的重要组成部件，负责处理数据，实现对数据的算术和逻辑运算。</p>
<p><strong>累加寄存器（AC）</strong>。</p>
<p>AC通常被称为累加器，它是一个通用寄存器，其<strong>功能是当运算器的算术逻辑单元执行算术或逻辑运算时，为ALU提供一个工作区。</strong>列如，在执行一个减法运算，先将被减数取出暂存在AC中，再从内存储器中取出减数，然后同AC的内容相减，将所得的结果送回AC中。运算的结果是放在累加器中的，运算器中至少要有一个累加寄存器。</p>
<p><strong>数据缓冲寄存器（DR）</strong>。</p>
<p>在对内存储器进行读写操作时，用DR暂存由内存储器读写的一条指令或一个数据字，将不同时间段内读写的数据隔离开。<strong>DR的主要作用为：作为CPU和内存，外部设备之间数据传送的中转站；作为CPU和内存，外围设备之间在操作速度上的缓冲；在单累加器结构的运算器中，数据缓冲寄存器还可兼作为操作数寄存器。</strong></p>
<p><strong>状态条件寄存器（PSW</strong>）。</p>
<p>PSW保存由算术指令和逻辑指令运行或测试的结果建立的各种条形码，主要分为状态标志和控制标志。这些标志通常分别由1位触发器保存，保存了当前指令执行完成之后的状态。通常，一个算术操作产生一个运算结果，而一个逻辑操作产生一个判决。</p>
<h3 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a><strong>控制器</strong></h3><p>控制器用于控制整个 CPU 的工作，它决定了计算机运算过程的自动化。它不仅要保证程序的正确执行，还要能够处理异常事件。它包括指令控制逻辑，时序控制逻辑，总线控制逻辑和中断控制逻辑等几个部分。</p>
<p><strong>指令寄存器（IR）：</strong>当CPU 执行一条指令时，先把它从内存储器取到缓冲寄存器中，再送入 IR 暂存，指令器根据 IR 的内存产生各种位操作指令，控制其他的祖成部件工作完成功能。</p>
<p><strong>程序计数器(PC)：</strong>PC 具有寄存信息和计数两种功能，又称为指令计数器。程序的执行分两种情况，一是顺序执行，二十转移执行。在程序开始执行前，将程序的起始地址送入PC，该地址在程序加载到内存时确定，因此PC的内存是程序第一条指令的地址。执行指令时，CPU 自动更改PC的内容，使其保持总是要执行下一条指令的地址。修改的过程只是简单地对PC加1.当遇到转移指令时，后继指令的地址根据当前指令的地址加上一个向前或向后转移的位移量得到，或者根据转移指令给出的直接转移地址得到。</p>
<p><strong>地址寄存器(AR)：</strong>AR 保存当前CPU 所访问的内存单元的地址。由于内存和CPU 存在操作速度上的差异，所以需要使用AR保持地址信息，直到内存的读写操作完成为止。</p>
<p><strong>指令译码器(ID)：</strong>指令包含操作码和地址码两部分，必须对操作码进行分析，以便识别所完成的操作。指令译码器就是对指令中的操作码字段进行分析解释，试别该指令规定的操作，向操作控制器发出具体的控制信号，控制各部件工作，完成所需的功能。</p>
<p>时序控制逻辑要为每条指令按时间顺序提供应有的控制信号。总线逻辑是为多个功能部件服务的信息通路的控制电路。中断控制逻辑用于控制各种中断请求，并根据优先级的高低对中断请求进行排序，逐个交给CPU 处理。</p>
<p><strong>寄存器组</strong></p>
<p>寄存器可分为专用寄存器和通用寄存器。运算器和控制器中的寄存器都是专用寄存器，其作用是固定的，通用寄存器用途广泛并可由程序员规定其用途，其数目因处理器不同有所差异。</p>
<p><strong>多核CPU</strong></p>
<p>核心又称为内核，是CPU最重要的祖成部分。CPU所有的计算，接受&#x2F;存储命令，处理数据都是由核心执行。各种CPU核心都具有固定的逻辑结构，一级缓存，二级缓存，执行单元，指令级单元和总线接口等逻辑单元都会有合理的布局。</p>
<p>多核即在一个单芯片上集成两个或更多的处理器内核，其中，每个内核都有自己的逻辑单元，控制单元，终端处理器，运算单元，一级 Cache，二级 Cache 共享或独有，其部件的完整性和单核处理器内核相比完全一致。</p>
<p>多核CPU系统最大的有点是可以满足用户同时进行多任务处理的要求。</p>
<h3 id="校验码"><a href="#校验码" class="headerlink" title="校验码"></a>校验码</h3><p>1.奇偶校验码</p>
<p>通过在编码中增加一位校验位来使编码中 1 的个位为奇数或者为偶数，从而使码距变为2。对于奇校验，它可以检测代码中奇数位出错的编码，但不能发现偶数位出错的情况，当合法编码中的奇数位发生了错误时，即编码中的 1 变成 0 或 0变成了1，则编码中 1 的个数的奇偶性就发生变化。</p>
<p>常用 水平奇偶校验码，垂直奇偶校验码和水平垂直校验码。</p>
<p>2.海明码</p>
<p>海明码是一种利用奇偶性检错和纠错的校验方法。海明码的构成方法是在数据位之间的特定位置上插入 K 个校验位，通过扩大码距实现检错和纠错。</p>
<p>3.循环冗余校验码</p>
<p><strong>采用模二除法运算的只有循环冗余检验CRC。</strong></p>
<p>广泛用于数据通信领域和磁介质存储系统中。它利用生成多项式为 K 个数据位产生 r 个校验位来进行编码，其编码长度为 <strong>k+r。校验码占 n - k 位。</strong></p>
<h2 id="计算机体系结构"><a href="#计算机体系结构" class="headerlink" title="计算机体系结构"></a>计算机体系结构</h2><p>计算机体系结构是指计算机的概念性结构和功能属性。</p>
<p>计算机组织是指计算机体系结构的逻辑实现，包括机器内的数据流和控制流的组成以及逻辑设计等（常称为计算机组成原理）</p>
<p>计算机实现是指计算机组织的物理实现。</p>
<p>宏观上按照处理机的数量分类：<strong>单处理系统，并行处理与多处理系统和分布式处理系统。</strong></p>
<p>单处理系统，利用一个处理单元与其他外部设备结合起来，实现存储，计算，通信，输入与输出等功能的系统。</p>
<p>并行处理与多处理系统。将两个以上的处理机互连起来，彼此进行通信协调，以便共同求解一个大问题的计算机系统。</p>
<p>分布式处理系统。指物理上远距离而松耦合的多计算机系统。其中物理上的远距离意味着通信时间与处理时间相比已不可忽略，在通信线路上的数据传输率要比在处理机内部总线上传输慢得多，这也正是松耦合的含义。</p>
<p>微观上按照并行程度分类：Flynn 分类法，冯泽云分类法，Handler 分类法和 Kuck 分类法。</p>
<p>Flynn 分类法：按照指令流和数据流的多少进行分类。TODO</p>
<h3 id="指令系统"><a href="#指令系统" class="headerlink" title="指令系统"></a>指令系统</h3><p>一个处理器支持的指令和指令的字节级编码称为其指令集体系结构，不同的处理器族支持不同的指令集体系结构，因此，一个程序被编译在一种机器上运行，往往不能在另外一种机器上运行。</p>
<p><strong>指令集体系结构的分类：</strong></p>
<p>1.操作数在CPU中的存储方式，即操作数从主存中取出后保存在什么地方。</p>
<p>2.显式操作数的数量，即在典型的指令中有多少个显式命名的操作数。</p>
<p>3.操作数的位置，即任一个ALU指令的操作数能否放在主存中，如何定位。</p>
<p>4.指令的操作，即在指令集中提供哪些操作。</p>
<p>5.操作数的类型与大小。</p>
<p>指令集体系可以分为三类：堆栈，累加器，寄存器组。</p>
<p><strong>通用寄存器（General-Purpose Register Machines,GRP）**的关键性优点是**编译程序能有效地使用寄存器**，无用论是计算表达式的值，还是从全局的角度使用寄存器来保存变量的值。在求解表达式时，寄存器比堆栈或者累加器能提供更加灵活的次序。更重要的是，</strong>寄存器能用来保存变量<strong>。当变量分配给寄存器时，访存流量就会减少，程序运行就会加速，而且代码密度也会得到改善。</strong>用户可以用指令集的两个主要特征来区分GPR体系结构。1.ALU指令有两个或者三个操作数。在三操作数格式中，指令包括两个源操作数和一个目的操作数；在二操作数格式中，有一个操作数即是源操作数又是目的操作数。第二个是ALU指令中有几个操作数是存储器地址，对于典型的ALU指令，这个数可能在1~3之间。**</p>
<h3 id="CISC-Complex-Instruction-Set-Computer-复杂指令集计算机"><a href="#CISC-Complex-Instruction-Set-Computer-复杂指令集计算机" class="headerlink" title="CISC (Complex Instruction Set Computer, 复杂指令集计算机)"></a><strong>CISC (Complex Instruction Set Computer, 复杂指令集计算机)</strong></h3><p>基本思想是：进一步增强原有指令的功能，用更复杂的新指令取代原先由软件子程序完成的功能，实现软件功能的硬化，导致机器的指令系统越来越庞大，复杂。</p>
<p>缺点：</p>
<p>1.指令集过分庞杂</p>
<p>2.微程序技术是CISC的重要支柱，每条复杂指令都要通过执行一段解释性微程序才能完成，这需要多个CPU周期，从而降低了机器的处理速度。</p>
<p>3.由于指令集过分庞大， 使高级语言编译程序选择目标指令的范围很大，并使编译程序本身冗长，复杂，从而难以优化编译使之生成真正高效的目标代码。</p>
<p>4.CISC强调完善的中断操作，导致动作繁多，设计复杂，研制周期长。</p>
<p>5.CISC给芯片设计带来很多困难，使芯片种类增多，出错几率增大，成本提高而成品率降低。</p>
<h3 id="RISC-Reduced-Instruction-Set-Computer-精简指令集计算机"><a href="#RISC-Reduced-Instruction-Set-Computer-精简指令集计算机" class="headerlink" title="RISC (Reduced Instruction Set Computer, 精简指令集计算机)"></a>RISC <strong>(Reduced Instruction Set Computer, 精简指令集计算机)</strong></h3><p>基本思想是通过减少指令总数和简化指令功能降低硬件设计的复杂度，使指令能单周期执行，并通过优化编译提高指令的执行速度，采用硬布线控制逻辑优化编译程序。</p>
<p>1.重叠寄存器窗口技术。在处理机中设置一个数量比较大的寄存器堆，并把它划分成很多个窗口。每个过程使用其中相邻的三个窗口和一个公共的窗口，而在这些窗口中有一个窗口是与前一个过程共用，还有一个窗口是与下一个过程共用的。与前一过程共用的窗口可以用来存放前一过程传送给本过程的参数，同时也存放本过程传送给前一过程的计算结果。同样，与下一过程共用窗口可以用来存放本过程传送给下一过程的参数和存放下一过程传送给本过程的计算结果。</p>
<p>2.优化编译技术。RISC使用大量的寄存器，如何合理地分配寄存器，提高寄存器的使用效率及减少访存次数等，都应通过编译技术的优化来实现。</p>
<p>3.超流水及超标量技术。位了进一步提高流水线速度而采用的技术。</p>
<p>4.硬布线逻辑与微程序相结合在微程序技术中。</p>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>面向高级程序语言的优化思路是尽可能缩小高级语言与机器语言之间的语义差距，以利于支持高级语言编译系统，缩短编译程序的长度和编译所需的时间。</p>
<p>面向操作系统的优化思路是进一步缩小操作系统与体系结构之间的语义差距，以利于减少操作系统运行所需的辅助时间，节省操作系统软件所占用的存储空间。操作系统的实现依赖于体系于体系结构对它的支持。</p>
<h3 id="指令的流水处理"><a href="#指令的流水处理" class="headerlink" title="指令的流水处理"></a>指令的流水处理</h3><p>指令控制方式有三种：顺序方式，重叠方式和流水方式。</p>
<p>1.顺序方式是指各条机器指令之间顺序串行地执行，执行完一条指令后才取下一条指令，而且每条机器指令内部的各个微操作也是顺序串行地执行。这种方式的优点是控制简单。缺点是速度慢，机器各部件的利用率低。</p>
<p>2.重叠方式是指在解释第K条指令的操作完成之前就可以开始解释 K+1 条指令。这种方式的优点是速度有所提高，控制也不太复杂。缺点是会出现冲突，转移和相关等问题。</p>
<p>3.流水方式是模仿工业生产过程的流水线，是把并行性或者并发性嵌入到计算机系统里的一种形式，它把重复的顺序处理过程分解为若干子过程，每个子过程能在专用的独立模块上有效地并发工作。</p>
<p><strong>RISC中采用的流水技术有三种：超流水线，超标量，以及超长指令字。</strong></p>
<p>1.超流水线技术。它通过细化流水，增加级数和提高主频，使得再每个机器周期内能完成一个甚至两个浮点操作。其实质是以时间换空间。超流水机器的特征是再所有的功能单元都采用流水，并有更高的时钟频率和更深的流水深度。由于它只限于指令级的并行，所有超流水机器的CPI指稍高。</p>
<p>2.超标量技术（Very Long Instruction Word,VLIW）技术。同时执行多条指令，其不同在于超标量依靠硬件来实现并行处理的调度，VLIW 则充分发挥软件的作用，而使硬件简化，性能提高。VLIW有更小的CPI值，但是需要有足够高的时钟并屡。</p>
<h3 id="阵列处理机，并行处理机和多处理机"><a href="#阵列处理机，并行处理机和多处理机" class="headerlink" title="阵列处理机，并行处理机和多处理机"></a><strong>阵列处理机，并行处理机和多处理机</strong></h3><p>并行性包括同时性和并发性。其中，同时性是指两个或两个以上的事件在同一时刻发生，并发性是指两个或者两个以上的事件在同一时间间隔内连续发生。</p>
<p>1.存储器操作并行。</p>
<p>2.处理器操作步骤并行（流水线处理机）</p>
<p>3.处理器操作并行（阵列处理机）</p>
<p>4.指令，任务，作业并行（多处理机，分布处理系统，计算机网络）</p>
<p>1.阵列处理机</p>
<p>阵列处理机将重复设置的多个处理单元（PU）按照一定方式连成阵列，在单个控制部件（CU）控制下，对分配给自己的数据进行处理，并行地完成一条指令所规定的操作。这是单指令流多数据流计算机，通过资源重复实现并行性。</p>
<p>2.并行处理机</p>
<p>SIMD 和 MIMD 是并行计算机。SIMD有共享存储器和分布存储器两种形式。</p>
<p>SIMD 将若干个存储器构成统一的并行处理机存储器，通过互联网络ICN为整个并行系统的所有处理单元共享。</p>
<p>3.多处理机</p>
<p>多处理机系统是由多台处理机组成的系统，每台处理机有属于自己的控制部件，可以执行独立的程序，共享一个主存储器和所有的外部设备。它是多指令流多数据流计算机。在多处理机系统中，机间的互连技术决定了多处理机的性能。多处理机之间的互连要满足高频带，低成本，连接方式的多样性以及在不规则通信情况下连接的无冲突性。</p>
<p>4.其他计算机</p>
<p>集群一般是指连接在一起的两个或多个计算机（结点）。集群计算机是一种并行或分布式处理系统，由很多连接在一起的独立计算机组成，像一个单集成的计算机资源一样协同工作，主要用于解决大型问题。计算机结点可以是一个单处理器或多处理器的系统，拥有内存，I&#x2F;O 设备和操作系统。连接在一起的计算机集群对用户和应用程序来说像一个单一的系统，这样的系统可以提供一种价格合理的且可获得所需性能和快速而可靠的服务的解决方案。</p>
<h3 id="存储系统"><a href="#存储系统" class="headerlink" title="存储系统"></a>存储系统</h3><p><strong>主存与辅存之间的交互功能可由硬件和软件结合起来实现。</strong></p>
<p>存储器的分类</p>
<p>存储器所处的位置可分为内存和外存。</p>
<p>内存：主存，用于存放机器当前运行所需要的程序和数据，以便向CPU提供信息。</p>
<p>外存：辅存，如磁盘，光盘等，用来存放当前不参加运行的大量信息，而在需要时调入内存。</p>
<p>读&#x2F;写存储器（Random Access Memory,RAM)。它指既能读取数据也能存入数据的存储器。</p>
<p>只读存储器。工作过程中仅能读取的存储器，根据数据的写入方式这种存储器可以细分为多种：</p>
<p>固定只读存储器（Read Only Memory,ROM）厂家生产时就写好数据，其内容只能读出，不能改变。一般用于存放系统程序BIOS和用于微程序控制。</p>
<p>可编程的只读存储器（Programmable Read Only Memory,PROM）其中的内容可以由用户一次性地写入，写入后不能再修改。</p>
<p>按访问方式分类</p>
<p><strong>按访问方式可分为地址访问的存储器和按内容访问的存储器。</strong></p>
<p>按寻址方式分类</p>
<p><strong>按寻址方式可分为随机存储器，顺序存储器和直接存储器。</strong></p>
<p>随机存储器（Random Access Memory,RAM）这种存储器可对任何存储单元存入或读取数据，访问任何一个存储单元所需的时间是相同的。</p>
<p>顺序存储器（Sequentially Addressed Memory,SAM）访问数据所需要的时间与数据所在的村存储位置相关，磁带是典型的顺序存储器。</p>
<p>直接存储器（Direct Addressed Memory,DAM）介于随机存取和顺序存取之间的一种寻址方式。磁盘是一种直接存取存储器，它对磁道的寻址是随机的，而再一个磁道内则是顺序寻址</p>
<h3 id="相联存储器"><a href="#相联存储器" class="headerlink" title="相联存储器"></a><strong>相联存储器</strong></h3><p>相联存储器是一种按内容访问的存储器。其工作原理就是把数据或数据的某一部分作为关键字，按顺序写入信息，读出时并行地将该关键字与存储器中的每一单元进行比较，找出存储器中所有与关键字相同的数据字，特别适合于信息的检索和更新。</p>
<p>相联存储器可用在高速缓冲存储器中，在虚拟存储器中用来作为段表，页表或快表存储器，用来数据库和知识库中。</p>
<p><strong>高速缓存</strong></p>
<p>高速缓存用来存放最活跃的程序和数据，位于CPU与主存之间；容量一般在 几千字节到几兆字节之间；速度一般比主存快5~10倍，由快速半导体存储器构成；其内容是主存局部域的副本，对程序员来说是透明的。</p>
<p>高速缓存中的地址映像方法</p>
<p>CPU工作时，送出的是主存单元的地址，而应从 Cache 存储器中读&#x2F;写信息。这就需要将主存地址转换成 Cache 存储器的地址，这种地址的转换称为地址映像。</p>
<p>1.直接映像：指主存的块与 Cache 块的对应关系是固定的。优点是地址变换很简单，缺点是灵活性差。</p>
<p>2.全相联映像。主存与 Cache 存储器均分成大小相同的块。主要优点是主存的块调入 Cache 的位置不受限制，十分灵活。其主要缺点是无法从主存块号中直接获得 Cache 的块号，变换比较复杂，速度比较慢。</p>
<p>3.组相联映像。规定组采用直接映像方式而采用全相联映像方式。</p>
<p><strong>替换算法</strong></p>
<p>1.随机替换算法</p>
<p>2.先进先出算法。</p>
<p>3.近期最少使用算法。</p>
<p>4.优化替换算法。</p>
<h2 id="输入-x2F-输出技术"><a href="#输入-x2F-输出技术" class="headerlink" title="输入&#x2F;输出技术"></a>输入&#x2F;输出技术</h2><h3 id="微型计算机中最常用的内存与接口的编址方法"><a href="#微型计算机中最常用的内存与接口的编址方法" class="headerlink" title="微型计算机中最常用的内存与接口的编址方法"></a>微型计算机中最常用的内存与接口的编址方法</h3><p><strong>内存与接口地址独立编址方法</strong></p>
<p>这种编址方法的缺点是用于接口的指令太少，功能太弱。</p>
<p><strong>内存与接口地址统一编址方法</strong></p>
<p>这种编址方法的有点是原则上用于内存的指令全都可以用于接口，这就大大地增强了对接口的操作功能，而且在至零上也不再区分内存或接口指令。</p>
<p>该编址方法的缺点在于整个地址空间被分为了两部分，其中一部分分配给接口使用，剩余的为内存所用，这经常会导致内存地址不连续。</p>
<h3 id="直接程序控制"><a href="#直接程序控制" class="headerlink" title="直接程序控制"></a>直接程序控制</h3><p>直接程序控制是指外设数据的输入&#x2F;输出过程是在CPU执行程序的控制下完成的。这种方式分为无条件传送和程序查询两种情况。</p>
<p><strong>无条件传送</strong></p>
<p>在这种情况下，外设总是准备好的，它可以无条件地随时接受CPU 发来的输出数据，也能够无条件地随时向CPU提供需要输入的数据。</p>
<p><strong>程序查询方式</strong></p>
<p>利用查询方式进行 输入&#x2F;输出，就是通过CPU执行程序来查询外设的状态，判断外设是否准备好接收数据或者准备好输入数据。</p>
<p>缺点：</p>
<p>1.降低了CPU的效率。</p>
<p>2.对外部的突发事件无法做出实时响应。</p>
<h3 id="中断方式"><a href="#中断方式" class="headerlink" title="中断方式"></a>中断方式</h3><p>利用中断方式完成数据的输入&#x2F;输出过程为：当 I&#x2F;0 系统与外设交换数据时，CPU无须等待也不必去查询 I&#x2F;O 的状态，而可以去处理其他任务。当I&#x2F;O系统准备好后，则发出中断请求信号通知 CPU，CPU接到中断请求信号后，保存正在执行程序的现场，转入I&#x2F;O中断服务程序的执行，完成与I&#x2F;O系统的数据交换，然后再返回被打断的程序继续执行。</p>
<p>系统中具有多个中断源的情况下，常用的处理方法有<strong>多中断信号线法(Multiple Interrupt Lines)，中断软件查询法（Sotware Poll），菊花链法（Daisy Chain），总线仲裁法和中断向量表法。</strong></p>
<h3 id="直接存储器存取方式"><a href="#直接存储器存取方式" class="headerlink" title="直接存储器存取方式"></a><strong>直接存储器存取方式</strong></h3><p>在计算机与外设交换数据的过程中，无论是无条件传送，利用查询方式传送还是利用中断方式传送，都需要由CPU通过执行程序来实现，这就限制了数据的传送速度。</p>
<p>直接内存存取（Direct Memory Access,DMA）是指数据再内存与 I&#x2F;O设备间的直接成块传送，即在内存与 I&#x2F;O 设备间传送一个数据块的过程中，不需要CPU的任何干涉，只需要 CPU在过程开始启动与操作结束时的处理，实际操作由DMA硬件直接执行完成，CPU可以在这个过程中执行别的任务。</p>
<p><strong>DMA 传送过程中无须 CPU的干预，整个系统总线完全交给了 DMAC，由它控制系统总线完成数据传送。</strong></p>
<h3 id="总线结构"><a href="#总线结构" class="headerlink" title="总线结构"></a>总线结构</h3><p>总线分为：数据总线，地址总线，控制总线</p>
<p>数据总线（Data Bus,DB）用来传送数据信息，是双向的。DB的宽度决定了 CPU和计算机其他设备之间每次交换数据的位数。</p>
<p>地址总线（Address Bus,AB）用于传送CPU 发出的地址信息，是单向的。地址总线的宽度决定了 CPU 的最大寻址能力。</p>
<p>控制总线（Control Bus,CB）用来传送控制信号，时序信号和状态信号。凡涉及到控制总线CB，均是以双向线表示。</p>
<p><strong>总线的性能直接影响到整机系统的性能，而且任何系统的研制和外围模块的开发都必须依从所采用的总线范围。总线技术随着微机结构的改进而不断发展与完善。</strong></p>
<h2 id="计算机安全"><a href="#计算机安全" class="headerlink" title="计算机安全"></a>计算机安全</h2><h3 id="加密技术和认证技术"><a href="#加密技术和认证技术" class="headerlink" title="加密技术和认证技术"></a>加密技术和认证技术</h3><p><strong>加密技术</strong></p>
<p>数据加密的最基本过程就是对原来为明文的文件或数据按某种加密算法进行处理，使其称为不可读的一段代码。</p>
<p>在安全保密中，可通过适当的密钥加密技术和管理机制来保证网络信息的通信安全。密钥加密技术的密码分为 <strong>对称密钥体制和非对称密钥体制两种。</strong></p>
<p><strong>对称加密技术</strong>：其特点是文件加密和解密使用相同的密钥，这种方法在密码学中称为对称加密算法。</p>
<p>数据加密标准（Digital Encryption Standard,DES）算法。</p>
<p>三重DES（3DES，或称TDEA）。在DES的基础上采用三重DES，其效果相当于将密钥长度加倍。</p>
<p>RC-5（Rivest Cipher 5）</p>
<p>国际数据加密算法（International Data Encryption Adleman,IDEA）.IDEA 在DES算法的基础上发展起来的，类似于三重 DES。密钥为 128位。</p>
<p>高级加密标准（Advanced Encryption Standard, AES）算法。</p>
<p><strong>非对称加密技术：</strong>非对称加密算法需要两个密钥，公开密钥和私有密钥。如果用公开密钥对数据进行加密，只有用对应的私钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。</p>
<p>非对称加密算法的保密性比较好，但加密和解密花费的时间长，速度慢，不适合对文件加密，只适合对少量数据进行加密。</p>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>Kai</span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>Permalink:</span>
                        <span><a href="https://ananonymousfriend.github.io/2021/09/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86/">https://ananonymousfriend.github.io/2021/09/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86/</a></span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2022 <a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                
                     <p class="copyright-item">
                         <span>Slogan:</span>
                         <span>Do you believe in <strong>DESTINY</strong>?</span>
                     </p>
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"># 学习笔记</a>
                    
                        <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"># 计算机基础</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2021/11/18/Kubernetes%20Pod/">Kubernetes Pod</a>
            
            
            <a class="next" rel="next" href="/2021/07/20/Go%20%E9%9D%A2%E8%AF%95%E9%A2%98/">Go 面试题</a>
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© Kai | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>

</html>