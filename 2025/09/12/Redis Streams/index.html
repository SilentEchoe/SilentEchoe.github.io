<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="Kai">





<title>Redis Streams | 面向兴趣编程</title>



    <link rel="icon" href="/icoimage.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 6.3.0"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">anonymity&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">anonymity&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6;    // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function () {
            tocbot.refresh(obj_merge(tocbot_default_config, { hasInnerContainers: true }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function () {
        tocbot.init(obj_merge(tocbot_default_config, { collapseDepth: 1 }));
    });

    function expandToc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, { collapseDepth: expanded ? 1 : DEPTH_MAX }));
        b.innerText = expanded ? 'Expand all' : 'Collapse all';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">Redis Streams</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">Kai</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">September 12, 2025&nbsp;&nbsp;17:11:00</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/">中间件</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在《<a href="https://silentechoe.github.io/2025/09/05/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%85%A5%E9%97%A8/">消息队列入门</a>》一文中简要介绍了分布式架构中消息队列的重要性，以及引入消息队列能带来哪些好处。消息队列支持组件通信的快速读写，很容易联想到Redis这种缓存中间件，因为Redis本身支持数据的高速访问，很符合消息队列对于读写性能需求。在轻量级应用的场景中，直接通过Redis来实现消息队列似乎是个不错的选择，无须引入更多的中间件设施，降低了运维成本……那么Redis适合做消息队列吗？</p>
<p>一般来说消息队列对外要提供提供三个保证：1.消息保序 2.处理重复消息 3.保证消息的可靠性。</p>
<p>在Redis 5.0版本前实现消息队列有多种方案，但无法完美实现上述保证，比如PUB&#x2F;SUB(发布&#x2F;订阅模式)，基于List的消息队列解决方案，基于Sorted Set的实现。</p>
<p>Redis中Pub&#x2F;Sub消息无法持久化，如果出现网络问题或中间件宕机，消息会直接丢失，无法保证消息的可靠性;Redis list没有消息多播，没有Ack机制，如果出现网络问题则会出现重复消费的问题;Redis Sorted Set不支持阻塞式获取消息，不支持分组消费。</p>
<h3 id="Redis-Streams"><a href="#Redis-Streams" class="headerlink" title="Redis Streams"></a>Redis Streams</h3><p>在官方文档中，Redis Stream被形容成一种”仅追加日志(append only log)”，又提供丰富的扩展命令操作来弥补日志局限性的数据结构。它不是Redis专门为消息队列设计的数据类型，但是它的特性满足了那些想要使用Redis作为消息队列的诉求。</p>
<p>XADD是Redis提供向流添加一条新数据的命令。每条流数据由一个或多个字段组成，这有点像字典或Redis中的哈希。不同的是它保证了有序，而且可以自动生成全局唯一的ID。这个全局唯一的ID由两部分组成，第一部分是数据插入时，以毫秒为单位计算的时间戳，第二部分表示插入消息在当前毫秒内的消息序号，以0编号开始。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; XADD mystream * name &quot;Alice&quot; action &quot;login&quot;</span><br><span class="line">&quot;1757662221963-0&quot;</span><br><span class="line">127.0.0.1:6379&gt; XADD mystream * name1 &quot;Alice1&quot; action1 &quot;login1&quot;</span><br><span class="line">&quot;1757662226486-0&quot;</span><br></pre></td></tr></table></figure>

<p>当执行上述代码，就可以往名为 mystream 的消息队列中插入一条数据，<code>name &quot;Alice&quot; action &quot;login&quot;</code> 是一个字段&#x2F;键值对，可以任意扩展。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt;  XREAD COUNT 2 STREAMS mystream 0</span><br><span class="line">1) 1) &quot;mystream&quot;</span><br><span class="line">   2) 1) 1) &quot;1757662221963-0&quot;</span><br><span class="line">         2) 1) &quot;name&quot;</span><br><span class="line">            2) &quot;Alice&quot;</span><br><span class="line">            3) &quot;action&quot;</span><br><span class="line">            4) &quot;login&quot;</span><br><span class="line">      2) 1) &quot;1757662226486-0&quot;</span><br><span class="line">         2) 1) &quot;name1&quot;</span><br><span class="line">            2) &quot;Alice1&quot;</span><br><span class="line">            3) &quot;action1&quot;</span><br><span class="line">            4) &quot;login1&quot;</span><br></pre></td></tr></table></figure>

<p>XREAD命令在读取消息时，<code>XREAD COUNT 1 STREAMS mystream 0</code>表示从最新的消息读一条信息。此外还可以选填<code>block</code>配置项，实现类似于<code>BRPOP</code>的阻塞读取操作。如果设置了block，再次执行XREAD命令就会阻塞：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; XREAD block 10000 streams mystream $</span><br><span class="line">(nil)</span><br><span class="line">(10.05s)</span><br></pre></td></tr></table></figure>

<p>Streams中可以使用XGROUP创建消费组(Consumer groups)，与Kafka中的consumer Group术语相同但实现不同。消息队列中的消息一旦被消费组里面的某一个消费者读取了，就不能再被该消费组内的其他消费者读取了。</p>
<p>使用消费组的目的是让组内多个消费者共同承担读取消息的任务，XREAD虽然能实现广播，但是在不想广播的情况下，可以通过消费组将消息划分给多个客户端，每个消费组只是消费组中的一个子集，这种方式可以保证消息读取负载在多个消费者间是均衡分布的。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; XGROUP CREATE mystream group1 0 MKSTREAM</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>

<p>为了保证消费者在发生故障或宕机后再次重启，依然可以读取未处理完的消息，Streams会自动使用内部队列(PENDING List)留存消费组里面每个消费者读取的消息，直到消费者使用<code>XACK</code>命令通知Streams，如果消费者没有发送XACK命令，那么消息依然会留存。使用<code>XPENDING</code>命令再次查看消费组中等待消费的消息时，可以看到(integer)的数量从2变成了1。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">消费者 c1 使用XREADGROUP命令拉取两条信息</span></span><br><span class="line">127.0.0.1:6379&gt; XREADGROUP GROUP group1 c1 COUNT 2 STREAMS mystream &gt;</span><br><span class="line">1) 1) &quot;mystream&quot;</span><br><span class="line">   2) 1) 1) &quot;1757662221963-0&quot;</span><br><span class="line">         2) 1) &quot;name&quot;</span><br><span class="line">            2) &quot;Alice&quot;</span><br><span class="line">            3) &quot;action&quot;</span><br><span class="line">            4) &quot;login&quot;</span><br><span class="line">      2) 1) &quot;1757662226486-0&quot;</span><br><span class="line">         2) 1) &quot;name1&quot;</span><br><span class="line">            2) &quot;Alice1&quot;</span><br><span class="line">            3) &quot;action1&quot;</span><br><span class="line">            4) &quot;login1&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">表示有两条正在等待被确认的信息:(<span class="built_in">integer</span>) 2</span></span><br><span class="line">127.0.0.1:6379&gt; XPENDING mystream group1</span><br><span class="line">1) (integer) 2</span><br><span class="line">2) &quot;1757662221963-0&quot;</span><br><span class="line">3) &quot;1757662226486-0&quot;</span><br><span class="line">4) 1) 1) &quot;c1&quot;</span><br><span class="line">      2) &quot;2&quot;</span><br><span class="line">            </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用XACK来确定1757662221963-0</span></span><br><span class="line">127.0.0.1:6379&gt; XACK mystream group1 1757662221963-0</span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">再次查看group1等待消费的消息</span></span><br><span class="line">127.0.0.1:6379&gt; XPENDING mystream group1</span><br><span class="line">1) (integer) 1</span><br><span class="line">2) &quot;1757662226486-0&quot;</span><br><span class="line">3) &quot;1757662226486-0&quot;</span><br><span class="line">4) 1) 1) &quot;c1&quot;</span><br><span class="line">      2) &quot;1&quot;</span><br></pre></td></tr></table></figure>

<p>Redis为Streams提供了多个命令来适应不同的场景，例如<code>XTRIM</code>来”裁剪”Stream来避免它无限增长，占满内存或磁盘。<a target="_blank" rel="noopener" href="https://redis.io/docs/latest/commands/?group=stream">官方文档</a>中包含了这部分命令的详细使用，这里不再过多赘述。</p>
<p>通过上述示例可以看出Streams已经提供了消息队列的保证，全局唯一ID保证了队列的顺序，<code>XACK</code>保证了重试，可靠性方面Redis本身也支持持久化和高可用。相比Kafka等专用做消息队列的中间件，Kafka和RabbitMQ被认为是更重量级的消息队列，在直觉上要显得更为稳妥。</p>
<p>如果要选用Redis作为消息队列，大部分原因在于它轻量级场景下的执行效率，有限的内存空间就能满足消息存储的需求，高性能特性支持快速的消息读写……它更适合一些比如发送邮件，导出报表，重试等轻量级消息队列的任务。这种任务生命周期较短，延迟性较低但又不要求长期存放。</p>
<h3 id="不仅仅只是消息队列"><a href="#不仅仅只是消息队列" class="headerlink" title="不仅仅只是消息队列"></a>不仅仅只是消息队列</h3><p>Redis的作者<a target="_blank" rel="noopener" href="http://invece.org/">Salvatore Sanfilippo</a>在谈论他设计的Streams时发表了一篇<a target="_blank" rel="noopener" href="https://antirez.com/news/128">博客</a>，表示他并不希望提到Streams时就直接把它与消息队列划等号，所以在本篇开头部分就表明了他的立场:Streams可以用来作为消息队列，但不仅限于消息队列。</p>
<p>作者认为“流(Streaming)”本身就是一种极好的模式和“思维模型”，它具有更强的通用性，消息队列的使用场景只不过是它其中一个部分。</p>
<p>Streams可以被认为是CSV的超集，在记录一些轻量级的数据时，很多开发者会直接生成一个CSV文件，并把这些数据在这个文件中追加进去。</p>
<p>那么为什么不把这些数据放入到内存中？</p>
<blockquote>
<p>CSV文件的局限性：</p>
<ol>
<li>做范围查询很难（效率低）。</li>
<li>存在大量冗余信息：时间几乎每条都一样，字段也重复。去掉的话又会失去灵活性，比如换一组字段就不方便。</li>
<li>偏移量只是文件的字节位置：只要文件结构变了，偏移就失效了，根本没有真正的主 ID 概念。条目没有唯一地址。</li>
<li>不能删除条目，只能标记无效，而且无法垃圾回收，除非重写日志。但日志重写通常很糟糕，能避免就避免。</li>
</ol>
<p>CSV文件的好处：</p>
<p>1.没有固定结构，字段可以变</p>
<p>2.生成简单</p>
<p>3.相当紧凑</p>
</blockquote>
<p>Redis Streams的设计思路就是为了保留这些优点的情况下，解决掉它的缺陷。所以它最终变成一个混合型数据结构，看起来像Sorted Set但是内部使用了多种实现方式：</p>
<blockquote>
<ul>
<li>宏节点里包含多个元素</li>
<li>数据结构使用 <strong>listpack</strong>，非常紧凑（整数即使作为字符串语义，仍以二进制存）</li>
<li>进一步应用了 <strong>增量压缩</strong> 和 <strong>相同字段压缩</strong></li>
<li>节点通过基数树链接，既省内存又支持高效按 ID&#x2F;时间检索</li>
</ul>
</blockquote>
<p>增量压缩的宏节点+基数树的方式能让<strong>顺序遍历</strong>达到O(M)级别，ID有序的方式更适合时间排序，相当于兼顾了<strong>List的顺序高效</strong>和 <strong>Sorted Set 的范围检索能力</strong>，内存的占用也极低，使用Sorted Set + Hash存储相同数量级的数据，内存占用率要比Stream要高13倍！极端情况下使用18GB内存可以让Streams存放约10亿条记录。</p>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>Kai</span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>Permalink:</span>
                        <span><a href="https://silentechoe.github.io/2025/09/12/Redis%20Streams/">https://silentechoe.github.io/2025/09/12/Redis%20Streams/</a></span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2022 <a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                
                     <p class="copyright-item">
                         <span>Slogan:</span>
                         <span></span>
                     </p>
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"># 消息队列</a>
                    
                        <a href="/tags/Redis/"># Redis</a>
                    
                        <a href="/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"># 中间件</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2025/09/28/%E6%9E%84%E9%80%A0%E8%BF%87%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F/">构造过程抽象</a>
            
            
            <a class="next" rel="next" href="/2025/09/05/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%85%A5%E9%97%A8/">消息队列入门</a>
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© Kai | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>

</html>